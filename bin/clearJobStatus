#! /usr/local/bin/bash

###############################################################################
# This script sets the status of jobs/modules to force the job/module to be
# scheduled at the next opportunity
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2013.01.06'


###############################################################################
# process options
###############################################################################
printMiniUsage() {
    $ECHO "Usage: $0 [-j <jobPath>] [-m <module>] [-v]"
}

printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# clearJobStatus (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 2013.01.06"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    printMiniUsage
    $ECHO "   Appends a status record to the end of a status file which indicates RESET at time"
    $ECHO "   zero -- effectively forcing the job to be scheduled at the next opportunity.  This"
    $ECHO "   can be used to manually override the job control JOB_INTERVAL or JOB_RETRY_FAILED"
    $ECHO "   settings."
    $ECHO "Options:"
    $ECHO "   -j   Specify the path to a particular jobFile"
    $ECHO "   -m   Specify the module to reset. If the module is given as '*' or '%' then the"
    $ECHO "        JOB_MODLIST_STATUS module will be reset."
    $ECHO "   -v   Provide verbose output"
    $ECHO "   if -j is not specified then all modules for all jobs will be reset."
    $ECHO "   if -m is not specified then all modules for each jobPath will be reset."
}


parseOptions() {
    while getopts ":j:m:v" arg; do
        case $arg in
            j) optJobPath=${OPTARG};;
            m) optModule=${OPTARG}
               [ x"$optModule" = x"*" ] && optModule=$JOB_MODLIST_STATUS
               [ x"$optModule" = x"%" ] && optModule=$JOB_MODLIST_STATUS
               ;;
            v) VERBOSE="1" ;;
            :) printFullUsage 1>&2
               $ECHO "Option -${OPTARG} requires an argument." 1>&2
               exit 1
               ;;
            *) printFullUsage 1>&2
               $ECHO "Option -${OPTARG} not recognized as a valid option." 1>&2
               exit 1
               ;;
        esac
    done
    COMMAND_LINE_PARMS=( "${@:$OPTIND}" )  #save rest of command line as array
}


###############################################################################
# main
###############################################################################
checkRunningUser
parseOptions "$@"; set -- "${COMMAND_LINE_PARMS[@]}"

# if the optJobPath is specified replace with full path but if it is a symlink
# do not dereferece/follow the link
if [ -n "$optJobPath" ]; then
    optJobDir=`$DIRNAME "$optJobPath"`
    optJobDir=`$READLINK -f "$optJobDir"`
    optJobPath=`$READLINK -f "$optJobDir"`/${optJobPath##*/}
fi

# find all the job directories with a JOB_CONTROL file
$FIND $JOB_ROOT -name $JOB_CONTROL | while read jobControlPath; do
    jobDir=${jobControlPath%/*}
    [ "$VERBOSE" ] && $ECHO "job dir: ${jobDir##*/}  ($jobDir)"

    # find all the jobs in the current job directory
    $FIND -L $jobDir -perm -0100 \( -type f -or -type l \) -mindepth 1 -maxdepth 1 | while read jobPath; do
        [ -n "$optJobPath" -a "$optJobPath" != "$jobPath" ] && continue
        [ -d ${jobPath}${JOB_STATUS_DIR_SUFFIX} ]           || continue
        
        jobFile=${jobPath##*/}
        [ "$VERBOSE" ] && $ECHO "    job: $jobFile"

        # reset the status files
        $FIND ${jobPath}${JOB_STATUS_DIR_SUFFIX} -type f -maxdepth 1 | while read statusPath; do
            modName=${statusPath##*/}
            [ -n "$optModule" -a "$optModule" != "$modName" ] && continue
 
            [ "$VERBOSE" ] && $ECHO "        setting status for module $modName"
            timeStamp=`$DATE -u +${DATE_FORMAT}z`
            statLine=`$SORT $statusPath 2>/dev/null | $TAIL -1`
            lastSuccessDate=`$ECHO "$statLine" | parseAssignment lastSuccessDate`
            lastFailureDate=`$ECHO "$statLine" | parseAssignment lastFailureDate`
            statLine=`$ECHO ""          | makeAssignment runDate         $timeStamp`
            statLine=`$ECHO "$statLine" | makeAssignment runState        RESET`
            statLine=`$ECHO "$statLine" | makeAssignment lastSuccessDate $lastSuccessDate`
            statLine=`$ECHO "$statLine" | makeAssignment lastFailureDate $lastFailureDate`
            $ECHO "$statLine" >> $statusPath
        done
    done
done 

