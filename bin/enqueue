#! /usr/local/bin/bash

###############################################################################
# This script enqueues jobs, after first checking to ensure that an identical
# job does not already exist in the queue.
#
# Each job file's name includes a priority, timestamp of when the job was
# queued, a description, and a checksum of its contents. The priority and
# timestamp are used to establish the processing order (a simple, sorted,
# directory listing will show the processing order).  The checksum is used
# to prevent jobs from being queued multiple times (before a job is enqueued
# all queues are searched for any job whose file name has the same checksum).
#
###############################################################################
# Queues
#   Single directory with a file for each enqueued job.
#
# Queued jobs
#   Are files with names of the form "qj_pp-timestamp_desc_crc32", where
#     qj:        literal 'qj' (abbr "queued job")
#     pp:        priority represented by a two digit integer (00=highest)
#     timestamp: the UTC seconds since the epoch
#     desc:      arbitrary human readable string (generally jobName_modName)
#     crc32:     the checksum of the file contents
#
# The queued jobFile itself has a very simple structure as follows:
#     jobDir:  <jobDir>
#     jobFile: <jobFile>
#     modName: <modName>
#
###############################################################################
# Modified enqueue to chack for duplicate jobs before adding a job into the
# execution queue.  This is done by making a checksum as part of the queued
# file's name, and searching the queues for any file with an identical
# checksum
#
# return code:  0     success
#               1     error
#               100   job already queued - enqueue cancelled
#
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012.10.14'


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# enqueue (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO "Usage: $0 -j <jobPath> -s <modName> [-p <priority>] [-v]"
    $ECHO "Options:"
    $ECHO "   -j <jobPath>   The canonical path to the executable job file.  If the jobPath"
    $ECHO "                  does not begin with a '/' then it is assumed to be a path"
    $ECHO "                  relative to JOB_ROOT ('$JOB_ROOT/'"
    $ECHO "                  will be prepended)"
    $ECHO "   -s <modName>   The module name to run the job for.  Athough this parameter"
    $ECHO "                  must be supplied it can be an emply string to indicated that"
    $ECHO "                  the job will be run to retrieve the module list from the"
    $ECHO "                  target."
    $ECHO "   -p <priority>  The priority as a two digit integer where 00 has the highest"
    $ECHO "                  priority and 99 the lowest.  Default = 50"
    $ECHO "   -v             Print verbose output"
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 -j <jobPath> -s <modName> [-p <priority>] [-v]"
}


parseOptions() {
    local opSsupplied
    while getopts ":j:s:p:v" arg; do
        case $arg in
            j) jobPath="${OPTARG}" ;;
            s) modName="${OPTARG}";  sOptionSupplied="1" ;;
            p) priority="${OPTARG}" ;;
            v) VERBOSE="1" ;;
            :) $ECHO "Option -${OPTARG} requires an argument." 1>&2
               printFullUsage 1>&2
               ;;
            *) $ECHO "Option -${OPTARG} not recognized as a valid option." 1>&2
               printFullUsage 1>&2
               ;;
        esac
    done

    if [ -z "$jobPath" ]; then
        $ECHO "Option -j must be supplied." 1>&2
        printMiniUsage 1>&2
        exit 1
    elif [ "${jobPath:0:1}" != "/" ]; then
        jobPath=${JOB_ROOT}/${jobPath}
    fi
    jobDir=${jobPath%/*}
    jobFile=${jobPath##*/}

    if [ -z "$sOptionSupplied" ]; then
        $ECHO "Option -s must be supplied." 1>&2
        printMiniUsage 1>&2
        exit 1
    fi

    priority=`$ECHO $priority | grep "^[0-9][0-9]$"`
    priority=${priority:-50}

    COMMAND_LINE_PARMS=( "${@:$OPTIND}" )  #save rest of command line as array
}


###############################################################################
# main
###############################################################################
checkRunningUser
parseOptions "$@"; set -- "${COMMAND_LINE_PARMS[@]}"

# ensure that the queueDirectory exists
$MKDIR -p $QUEUE_ROOT

# create a candidate queue file and populate
tmpPath=`$MKTEMP ${QUEUE_ROOT}/tmp_XXXXX`
[ "$VERBOSE" ] && $ECHO "            canadidate jobFile: $tmpPath"

$ECHO jobDir:   $jobDir   >> $tmpPath
$ECHO jobFile:  $jobFile  >> $tmpPath
$ECHO modName:  $modName  >> $tmpPath
$ECHO jobParms: "$@"      >> $tmpPath

# check that the candidate file is not a duplicate of an already queued job
crc=`$CKSUM $tmpPath | $SED -e 's/^\([[:alnum:]]*\).*/\1/'`
isDup=`$FIND $QUEUE_ROOT -type f -name qj_\*_$crc`
if [ -z "$isDup" ]; then
    timeStamp=`$DATE -u +${DATE_FORMAT}z`
    qjPath=$QUEUE_ROOT/qj_${priority}-${timeStamp}_${jobFile}_${modName:-$JOB_MODLIST_STATUS}_${crc}
    $MV $tmpPath $qjPath
    [ "$VERBOSE" ] && $ECHO "            ENQUEUED as: $qjPath"
else
    [ "$VERBOSE" ] && $ECHO "            job already queued as: ${isDup##*/}"
    $RM -f $tmpPath
    exit 100
fi

