#! /usr/local/bin/bash

###############################################################################
# This script enqueues jobs, after first checking to ensure that an identical
# job does not already exist in the queue.
#
# Each job file's name includes a priority, timestamp of when the job was
# queued, a description, and a checksum of its contents. The priority and
# timestamp are used to establish the processing order (a simple, sorted,
# directory listing will show the processing order).  The checksum is used
# to prevent jobs from being queued multiple times (before a job is enqueued
# all queues are searched for any job whose file name has the same checksum).
#
###############################################################################
# Queues
#   Single directory with a file for each enqueued job.
#
# Queued jobs
#   Are files with names of the form "qj_pp-timestamp_desc_crc32", where
#     qj:        literal 'qj' (abbr "queued job")
#     pp:        priority represented by a two digit integer (00=highest)
#     timestamp: the UTC seconds since the epoch
#     desc:      arbitrary human readable string (generally jobName_modName)
#     crc32:     the checksum of the file contents
#
# The queued jobFile itself has a very simple structure as follows:
#     jobDir:  <jobDir>
#     jobFile: <jobFile>
#     modName: <modName>
#
###############################################################################
# Modified enqueue to chack for duplicate jobs before adding a job into the
# execution queue.  This is done by making a checksum as part of the queued
# file's name, and searching the queues for any file with an identical
# checksum
#
# return code:  0     success
#               1     error
#               100   job already queued - enqueue cancelled
#
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012-10-14'


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# enqueue (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO "Usage: $0 -j <jobPath> -s <modName> [-p <priority>] [-v]"
    $ECHO "Options:"
    $ECHO "   -j <jobPath>   The canonical path to the executable job file"
    $ECHO "   -s <modName>   The module name to run the job for.  Athough this parameter"
    $ECHO "                  must be supplied it can be an emply string to indicated that"
    $ECHO "                  the job will be run to retrieve the module list from the"
    $ECHO "                  target."
    $ECHO "   -p <priority>  The priority as a two digit integer where 00 has the highest"
    $ECHO "                  priority and 99 the lowest.  Default = 50"
    $ECHO "   -v             Print verbose output"
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 <jobName> [<jobParm> [..]]"
}


parseOptions() {
    local opSsupplied
    while getopts ":j:s:p:v" arg; do
        case $arg in
            j) jobPath="${OPTARG}" ;;
            s) modName="${OPTARG}"
               sOptionSupplied="1" ;;
            p) jobPriority="${OPTARG}" ;;
            v) VERBOSE="1" ;;
            :) echo "Option -${OPTARG} requires an argument." 1>&2
               exit 1
               ;;
            *) echo "Option -${OPTARG} not recognized as a valid option." 1>&2
               exit 1
               ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    [ -z "jobPath" ] && printFullUsage 
    jobDir=${jobPath%/*}
    jobFile=${jobPath##*/}

    [ -z "sOptionSupplied" ] && printFullUsage

    jobPriority=`echo $priority | grep "^[0-9][0-9]$"`
    jobPriority=${priority:-50}

    #if [ $# -eq 0 ]; then
    #    printFullUsage
    #fi
}


###############################################################################
# main
###############################################################################
checkRunningUser
parseOptions

# ensure that the queueDirectory exists
mkdir -p $QUEUE_ROOT

# create a candidate queue file and populate
tmpPath=`$MKTEMP $(QUEUE_ROOT)/tmp_XXXXX`
[ "$VERBOSE" ] && echo "canadidate jobFile: $tmpPath"

$ECHO 'jobDir:  $jobDir'   >> $tmpPath
$ECHO 'jobFile: $jobFile'  >> $tmpPath
$ECHO 'modName: $modName'  >> $tmpPath

# check that the candidate file is not a duplicate of an already queued job
crc=`cksum $tmpFile | sed 's/^\([[:alnum:]]*\).*/\1/'`
isDup=`find $QUEUE_ROOT -type f -name qj_\*_$crc`
if [ -z "$isDup" ]; then
    timeStamp=`$DATE -u +%s`
    qjPath=$QUEUE_ROOT/qj_${priority}-${timeStamp}_${jobFile}_${modName}_${crc}
    mv $tmpPath $qjPath
    [ "$VERBOSE" ] && echo "    ENQUEUED as: $qjPath"
else
    [ "$VERBOSE" ] && echo "    job already queued as: $qjPath"
    rm -f $tmpPath
    exit 100
fi

