#! /usr/local/bin/bash

###############################################################################
# This script spawns multiple copies of itself and each copy pulls and runs
# the job at the top of the queue (priority / FIFO order).
#
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012-10-14'


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# runQueue (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO "Usage: $0 [<runnerNumber>]"
    $ECHO "   This script spawns multiple copies of itself and each copy pulls and runs"
    $ECHO "   the job at the top of the queue (priority / FIFO order)."
    $ECHO "Options:"
    $ECHO "   runnerNumber: a unique id to identify an instance of this script"
    $ECHO "                 from other instances. runnerNumber will be in the"
    $ECHO "                 range 1 to QUEUE_RUNNERS"
    $ECHO "   if called without the runnerNumber parameter then QUEUE_RUNNERS"
    $ECHO "   instances will be spawned each with a distinct runnerNumber"
    $ECHO 
    $ECHO " If the queued job does not specify a module then the job will be invoked"
    $ECHO " with the -j option, and if a module is specified the job will be invoked"
    $ECHO " with the -s."
    $ECHO 
    $ECHO " All job files must accept additional command line parameters and in turn "
    $ECHO " append them to the command line when calling backupGT.  Furthermore the"
    $ECHO " return code from the job file should be 0 for success, non-zero for failure"
    $ECHO " as returned from backupGT."
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 [<queueName>]"
}


###############################################################################
# main
#   - create a queueRunner specific mutex in the queue (mark with a timestamp)
#   - wait for potential competing queueRunners to create their mutex
#   - check for the existence of other mutexes in the queue
#   - if a mutex exists determine the job for which it marks as running
#       - if the job is still running then cleanup and quit
#   - remove any stale mutexes from the queue
#   - read the head of the queue and 
#       - launch the job to which it refers
#       - store the process info with the mutex
#   - wait for the job to complete
#       - remove the mutex
###############################################################################
checkRunningUser

case "$#" in
    0) for qrNum in `$SEQ $QUEUE_RUNNERS`; do
           $0 ${qrNum} &    # re-launch this script for each queueRunner
       done
       exit
       ;;

    1) qrNum="$1"
       ;;

    *) printFullUsage
       ;;
esac

queueDir="$QUEUE_ROOT"

# check that the queueDir exists
if [ ! -d "$queueDir" ]; then
    $ECHO "$0: ERROR: queue direcotry '$queueDir' does not exist"
    exit 1
fi

# create a mutex in the queue (mark with a timestamp
timeStamp=`$DATE -u +%s`
thisMutex=`$MKTEMP $queueDir/mutex_${qrNum}_${timeStamp}_XXXXX`
$ECHO "$$" > $thisMutex
$SLEEP 1

# see if thisMutex is governing for this qrNum
for mutex in $queueDir/mutex_${qrNum}*; do
    if [ "$mutex" = $thisMutex ]; then
        #this mutex is controlling
        break
    fi
    mutexPid=`$CAT $mutex`
    if $PS -o pid,command -p $mutexPid | $GREP -q "^$mutexPid"; then
        # other queueRunner is still running
        $RM -f $thisMutex
        exit 0
    else
        # queueRunner is defunct, remove stale mutex
        $RM -f $mutex
    fi
done

# okay lets get the head of the queue
firstQueuedJob=`$LS $queueDir/qj_* 2>/dev/null | $HEAD -1`
if [ -z "$firstQueuedJob" ]; then
    # no jobs left to run
    $RM -f $thisMutex
    exit 0
fi

# rename it to ensure that we have exclusive control of the entry
mxqj="$queueDir/mx_${qrNum}_${firstQueuedJob}"
$MV "$queueDir/$firstQueuedJob" "$mxqj" 2>/dev/null
if [ ! -f "$mxqj" ];
    # some other queueRunner grabbed the entry before us
    $RM -f $thisMutex
    exec $0 $* &    # try again
fi

# so now we have a queue entry lets run it
jobDir=` $AWK '/^jobDir:/  {print $2}' "${mxqj}"`
jobFile=`$AWK '/^jobFile:/ {print $2}' "${mxqj}"`
modName=`$AWK '/^modName:/ {print $2}' "${mxqj}"`
if [ -z "$modName" ]; then
    ${jobDir}/${jobFile} -j ${jobDir}/${jobFile}${JOB_MODLIST_SUFFIX}
    rc=$?
else
    ${jobDir}/${jobFile} -s "$modName"
    rc=$?
fi

# lets append a status entry to the status file
statusDir="${jobDir}/${jobFile}${JOB_STATUS_DIR_SUFFIX}"
statusPath="${statusDir}/${modName}"
statLine=`$SORT -n $statusPath 2>/dev/null | $TAIL -1`
if [ "$rc" -eq 0 ]; then
    statLine=`$ECHO "$statLine" | makeAssignment curState SUCCESS`
    statLine=`$ECHO "$statLine" | makeAssignment lastSuccessTimeStamp $timeStamp`
    statLine=`$ECHO "$statLine" | makeAssignment lastSuccessDate $(timeStamp2Date $timeStamp)`
else
    statLine=`$ECHO "$statLine" | makeAssignment curState SUCCESS`
    statLine=`$ECHO "$statLine" | makeAssignment lastFailureTimeStamp $timeStamp`
    statLine=`$ECHO "$statLine" | makeAssignment lastFailureDate $(timeStamp2Date $timeStamp)`
fi
$MKDIR -p $statusDir    #ensure that the job status dir exists
$ECHO "$statLine" >> $statusPath

# dequeue completed job and cleanup
$RM -f $mxqj
$RM -f $thisMmutex

# restart next instance of this queueRunner
exec $0 ${qrNum} 
