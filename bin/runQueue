#! /usr/local/bin/bash

###############################################################################
# This script finds the job at the head of a queue and runs it.
###############################################################################
# Queue entries
#   Are files with names of the form "qe_pp-timestamp_desc_<crc32>" and
#   which have as their first line of content the full path name of the job
#   executable to run, followed by a line for each parameter to place on the
#   command line when the job is run.
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012-10-14'


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# runQueue (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO
    $ECHO "Usage: $0 [<runnerNumber>]"
    $ECHO "   runnerNumber: a unique id to identify an instance of this script"
    $ECHO "                 from other instances. runnerNumber will be in the"
    $ECHO "                 range 1 to QUEUE_RUNNERS"
    $ECHO "   if called without the runnerNumber parameter then QUEUE_RUNNERS"
    $ECHO "   instances will be spawned each with a distinct runnerNumber"
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 [<queueName>]"
}


###############################################################################
# main
#   - create a queueRunner specific mutex in the queue (mark with a timestamp)
#   - wait for potential competing queueRunners to create their mutex
#   - check for the existence of other mutexes in the queue
#   - if a mutex exists determine the job for which it marks as running
#       - if the job is still running then cleanup and quit
#   - remove any stale mutexes from the queue
#   - read the head of the queue and 
#       - launch the job to which it refers
#       - store the process info with the mutex
#   - wait for the job to complete
#       - remove the mutex
###############################################################################
checkRunningUser
case "$#" in
    0) for qrNum in `$SEQ $QUEUE_RUNNERS`; do
           $0 ${qrNum} &    # re-launch this script for each queueRunner
       done
       exit
       ;;

    1) qrNum="$1"
       ;;

    *) printFullUsage
       ;;
esac

queueDir="$QUEUE_ROOT"

# check that the queueDir exists
if [ ! -d "$queueDir" ]; then
    $ECHO "$0: ERROR: queue direcotry '$queueDir' does not exist"
    exit 1
fi

# create a mutex in the queue (mark with a timestamp
timeStamp=`$DATE -u +%s`
thisMutex=`$MKTEMP $queueDir/mutex_${qrNum}_${timeStamp}_XXXXX`
$ECHO "$$" > $thisMutex
$SLEEP 1

# see if thisMutex is governing for this qrNum
for mutex in $queueDir/mutex_${qrNum}*; do
    if [ "$mutex" = $thisMutex ]; then
        #this mutex is controlling
        break
    fi
    mutexPid=`$CAT $mutex`
    if $PS -o pid,command -p $mutexPid | $GREP -q "^$mutexPid"; then
        # other queueRunner is still running
        $RM -f $thisMutex
        exit 0
    else
        # queueRunner is defunct, remove stale mutex
        $RM -f $mutex
    fi
done

# okay lets get the head of the queue
queueEntry=`$LS $queueDir/qe_* 2>/dev/null | $HEAD -1`
if [ -z "$queueEntry" ]; then
    # no jobs left to run
    $RM -f $thisMutex
    exit 0
fi

# rename it to ensure that we have exclusive control of the entry
mxqe="$queueDir/mx_${qrNum}_${queueFile}"
$MV "$queueDir/$queueFile" "$mxqe" 2>/dev/null
if [ ! -f "$mxqe" ];
    # some other queueRunner grabbed the entry before us
    $RM -f $thisMutex
    exec $0 $* &    # try again
fi

# so now we have a queue entry lets run it and update the status
jobDir=` $AWK '/^# jobDir:/  {print $3}' "${mxqe}"`
jobFile=`$AWK '/^# jobFile:/ {print $3}' "${mxqe}"`
modName=`$AWK '/^# modName:/ {print $3}' "${mxqe}"`
$mxqe
rc=$?
if [ $? -eq 0 ]; then   #success
    modLine=`$GREP "^${modName}	" ${jobDir}/${JOB_MODLIST_PREFIX}${jobFile}`
    modLine=`$ECHO $modLine | makeAssignment curState SUCCESS`
    modLine=`$ECHO $modLine | makeAssignment lastSuccessTimeStamp $timeStamp`
    modLine=`$ECHO $modLine | makeAssignment lastSuccessDate $(timeStamp2Date $timeStamp)`
    $SED -i "/^${modName}	/s/.*/${modLine}/" ${jobDir}/${JOB_MODLIST_PREFIX}${jobFile}
else #failure
    modLine=`$GREP "^$modName	" ${jobDir}/${JOB_MODLIST_PREFIX}${jobFile}`
    modLine=`$ECHO $modLine | makeAssignment curState SUCCESS`
    modLine=`$ECHO $modLine | makeAssignment lastFailureTimeStamp $timeStamp`
    modLine=`$ECHO $modLine | makeAssignment lastFailureDate $(timeStamp2Date $timeStamp)`
    $SED -i "/^${modName}	/s/.*/${modLine}/" ${jobDir}/${JOB_MODLIST_PREFIX}${jobFile}
fi

# dequeue completed job and cleanup
$RM -f $mxqe
$RM -f $thisMmutex

