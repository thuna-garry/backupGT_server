#! /usr/local/bin/bash

###############################################################################
# This script spawns multiple copies of itself and each copy pulls and runs
# the job at the top of the queue (priority / FIFO order).
#
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012-10-14'


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# runQueue (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO "Usage: $0 [-v] [<runnerNumber>]"
    $ECHO "   This script spawns multiple copies of itself and each copy pulls and runs"
    $ECHO "   the job at the top of the queue (priority / FIFO order)."
    $ECHO "Options:"
    $ECHO "   runnerNumber: a unique id to identify an instance of this script"
    $ECHO "                 from other instances. runnerNumber will be in the"
    $ECHO "                 range 1 to QUEUE_RUNNERS"
    $ECHO "   if called without the runnerNumber parameter then QUEUE_RUNNERS"
    $ECHO "   instances will be spawned each with a distinct runnerNumber"
    $ECHO 
    $ECHO " If the queued job does not specify a module then the job will be invoked"
    $ECHO " with the -j option, and if a module is specified the job will be invoked"
    $ECHO " with the -s."
    $ECHO 
    $ECHO " All job files must accept additional command line parameters and in turn "
    $ECHO " append them to the command line when calling backupGT.  Furthermore the"
    $ECHO " return code from the job file should be 0 for success, non-zero for failure"
    $ECHO " as returned from backupGT."
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 [<queueName>]"
}


parseOptions() {
    local opSsupplied
    while getopts ":v" arg; do
        case $arg in
            v) VERBOSE="1" ;;
            :) $ECHO "Option -${OPTARG} requires an argument." 1>&2
               exit 1
               ;;
            *) $ECHO "Option -${OPTARG} not recognized as a valid option." 1>&2
               exit 1
               ;;
        esac
    done
    COMMAND_LINE_PARMS=( "${@:$OPTIND}" )  #save rest of command line as array
}


###############################################################################
# main
#   - create a queueRunner specific mutex in the queue (mark with a timestamp)
#   - wait for potential competing queueRunners to create their mutex
#   - check for the existence of other mutexes in the queue
#   - if a mutex exists determine the job for which it marks as running
#       - if the job is still running then cleanup and quit
#   - remove any stale mutexes from the queue
#   - read the head of the queue and 
#       - launch the job to which it refers
#       - store the process info with the mutex
#   - wait for the job to complete
#       - remove the mutex
###############################################################################
checkRunningUser
parseOptions "$@"; set -- "${COMMAND_LINE_PARMS[@]}"

case "$#" in
    0) for qrNum in `$SEQ $QUEUE_RUNNERS`; do
           [ "$VERBOSE" ] && $ECHO "${0}: spawning queueRunner $qrNum"
           $0 `[ "$VERBOSE" ] && $ECHO "-v"` ${qrNum} &
       done
       exit
       ;;

    1) qrNum="$1"
       ;;

    *) printFullUsage
       ;;
esac

#----------------
# check that the queueDir exists
#----------------
queueDir="$QUEUE_ROOT"
if [ ! -d "$queueDir" ]; then
    $ECHO "$0: ERROR: queue direcotry '$queueDir' does not exist"
    exit 1
fi


#----------------
# create a mutex in the queue (mark with a timestamp)
#----------------
timeStamp=`$DATE -u +%s`
thisMutex=`$MKTEMP $queueDir/mutex_${qrNum}_${timeStamp}_XXXXX`
$ECHO "$$" > $thisMutex
$SLEEP 1


#----------------
# see if thisMutex is governing for this qrNum
#----------------
for mutex in $queueDir/mutex_${qrNum}*; do
    [ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) checking mutex $mutexPid"
    if [ "$mutex" = $thisMutex ]; then
        #this mutex is controlling
        break
    fi
    mutexPid=`$CAT $mutex`
    if $PS -o pid,command -p $mutexPid | $GREP -q "^$mutexPid"; then
        [ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) another istance is controlling - exiting"
        $RM -f $thisMutex
        exit 0
    else
        # queueRunner is defunct, remove stale mutex
        $RM -f $mutex
    fi
done
[ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) is controlling mutex=${thisMutex##*/}"


#----------------
# get the head of the queue
#----------------
firstQueuedJobPath=`$LS $queueDir/qj_* 2>/dev/null | $HEAD -1`
if [ -z "$firstQueuedJobPath" ]; then
    [ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) queue is empty - exiting"
    $RM -f $thisMutex
    exit 0
fi
[ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) queue head is ${firstQueuedJobPath##*/}"


#----------------
# rename it to ensure that we have exclusive control of the entry
#----------------
mxqj="$queueDir/mx_${qrNum}_${firstQueuedJobPath##*/}"
$MV "$firstQueuedJobPath" "$mxqj" 2>/dev/null
if [ ! -f "$mxqj" ]; then
    [ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) competing queue runnerqueue took head; restarting"
    $RM -f $thisMutex
    exec $0 `[ "$VERBOSE" ] && $ECHO "-v"` ${qrNum}
fi
[ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) has dequeued head as ${mxqj##*/}"


#----------------
# now we have a queue entry so run it
#----------------
jobDir=` $AWK '/^jobDir:/  {print $2}' "${mxqj}"`
jobFile=`$AWK '/^jobFile:/ {print $2}' "${mxqj}"`
modName=`$AWK '/^modName:/ {print $2}' "${mxqj}"`
if [ -z "$modName" ]; then
    [ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$):" \
        ${jobDir}/${jobFile} -j ${jobDir}/${jobFile}${JOB_MODLIST_SUFFIX}
    ${jobDir}/${jobFile} -j ${jobDir}/${jobFile}${JOB_MODLIST_SUFFIX}
    rc=$?
else
    [ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$):" \
        ${jobDir}/${jobFile} -s "$modName"
    ${jobDir}/${jobFile} -s "$modName"
    rc=$?
fi


#----------------
# append a status entry to the status file
#----------------
statusDir="${jobDir}/${jobFile}${JOB_STATUS_DIR_SUFFIX}"
statusPath="${statusDir}/${modName:-$JOB_MODLIST_STATUS}"
statLine=`$SORT $statusPath 2>/dev/null | $TAIL -1`
if [ "$rc" -eq 0 ]; then
    [ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) success - updating status"
    statLine=`$ECHO "$statLine" | makeAssignment curTimeStamp $(timeStamp2Date $timeStamp)`
    statLine=`$ECHO "$statLine" | makeAssignment curState SUCCESS`
    statLine=`$ECHO "$statLine" | makeAssignment lastSuccessTimeStamp $timeStamp`
    statLine=`$ECHO "$statLine" | makeAssignment lastSuccessDate $(timeStamp2Date $timeStamp)z`
else
    [ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) failure - updating status"
    statLine=`$ECHO "$statLine" | makeAssignment curTimeStamp $(timeStamp2Date $timeStamp)`
    statLine=`$ECHO "$statLine" | makeAssignment curState FAILURE`
    statLine=`$ECHO "$statLine" | makeAssignment lastFailureTimeStamp $timeStamp`
    statLine=`$ECHO "$statLine" | makeAssignment lastFailureDate $(timeStamp2Date $timeStamp)z`
fi
$MKDIR -p $statusDir    #ensure that the job status dir exists
$ECHO "$statLine" >> $statusPath

 
#----------------
# dequeue completed job and cleanup
#----------------
$RM -f $mxqj
$RM -f $thisMutex


#----------------
# restart next instance of this queueRunner
#----------------
[ "$VERBOSE" ] && $ECHO "queueRunner_$qrNum ($$) exec'ing new instance."
exec $0 `[ "$VERBOSE" ] && $ECHO "-v"` ${qrNum}

