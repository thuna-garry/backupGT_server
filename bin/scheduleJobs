#! /usr/local/bin/bash

###############################################################################
# This script finds jobs that haven't successfully run within a prescribed
# time interval and queues them for execution
#
###############################################################################
# todo: rewrite these descriptions
# Jobs
#   Implemented as runnable files (typically shell scripts) within directories
#   named as JOB_ROOT.NNNN where NNNN is the duration in minutes after the
#   last successful run of the job that the job should be (re)queued for 
#   execution
#
#   Example: if the configuration variable JOB_ROOT is ~/backupGT/jobs/ then
#   this script will find directories named ~/backupGT/jobs/jobs.NNNN.
#   If then, ~/backupGT/jobs/job.14400 exists then for each job file found
#   directly within ~/backupGT/jobs/job.14400, a check will be made to see
#   that the job has successfully been run within the last 14400 minutes
#   (1 day in this example).  
#  
# Job Status
#   The need to re-queue a job (lack of successful completion) is determined as
#   follows:
#         - if there is a status file for the job that indicates 
#           the job did not complete successfully (ie the status file
#           name will contain the string FAILURE)
#         - see if there is a status file for the job whose modification
#           time is older than the prescribed interval
#         - there are no status files for this job
# 
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012-06-28'


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# scheduleJobs (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO
    $ECHO "Usage: $0 [-v]"
    $ECHO "   search the JOB_ROOT for job files that have not successfully completed"
    $ECHO "   within the last NNNN minutes.  NNNN is determined by the name of the "
    $ECHO "   directory (which must be job.NNNN) in which the job file is found."
    $ECHO 
    $ECHO "  -v  verbose: prints detail of processing to stdout. "
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 [-v]"
}


###############################################################################
# main
###############################################################################
COMMAND_PATH=`$READLINK -f "$0"`
COMMAND_PARMS=( "$@" )

checkRunningUser
while getopts ":v" arg; do
    case $arg in
        v) VERBOSE="1" ;;
        *) $ECHO "Option -${OPTARG} not recognized as a valid option." 1>&2
           printFullUsage 1>&2
           exit 1
           ;;
    esac
done

for jobControlFile in `$FIND $JOB_ROOT -name $JOB_CONTROL`; do   # all the job directories with a JOB_CONTROL file
    jobDir=${jobControlFile%/*}
    [ "$VERBOSE" ] && echo "job dir: $jobDir"

    JOB_INTERVAL=1440     #set default 1 day
    JOB_RETRY_FAILED=60   #set default 1 hour
    . $jobControlFile

    for jobPath in `$FIND $jobDir -perm -0100 -type f -mindepth 1 -maxdepth 1`; do   # all the jobs in the current job directory
        jobFile=${jobPath##*/}
        [ "$VERBOSE" ] && echo "    job: $jobFile"

        # if a custom job control file exists then source it
        [ -f "${jobPath}${JOB_CONTROL}" ] && . "${jobPath}${JOB_CONTROL}"

        #----------------
        # consider the job file itself
        #----------------
        case $SYSTEM_TYPE in
            bsd)   findOp="-ctime -${JOB_INTERVAL}m" ;;
            linux) findOp="-mmin  -${JOB_INTERVAL}"  ;;
        esac
	recentModList="`$FIND ${jobDir} -name ${JOB_MODLIST_PREFIX}${jobFile} $findOp 2>/dev/null`"
        if [ -z "$recentModList" ]; then
            [ "$VERBOSE" ] && echo "        ENQUEING (modlist missing or older than $JOB_INTERVAL min)"
#todo purge queues of any instances of this job
            ${COMMAND_PATH%/*}/enqueue "$jobPath" "-j" "$jobPath" "-q"
            continue
        fi
        
        #----------------
        # now consider the modules
        #----------------
        $CAT $recentModList | while read modName modComment; do
            [ "$VERBOSE" ] && echo '        mod: ' $modName
            statusEntry=`grep "^$modName" "${jobDir}/${JOB_STATUS_PREFIX}${jobFile}" 2>/dev/null`
            curState=`            echo "$statusEntry" | parseAssignment curState`
            lastSuccessTimeStamp=`echo "$statusEntry" | parseAssignment lastSuccessTimeStamp`
            lastFailureTimeStamp=`echo "$statusEntry" | parseAssignment lastFailureTimeStamp`
         
            
            case x$curState in
                xSUCCESS)
                    maxAge=`$EXPR $JOB_INTERVAL \* 60`
		    needToQueue=`isTimeStampTooOld ${lastSuccessTimeStamp:-1} $maxAge`
                    if [ $needToQueue ]; then
                        [ "$VERBOSE" ] && echo "            ENQUEUE: curState=$curState too old ($JOB_INTERVAL max age)"
                    else
                        [ "$VERBOSE" ] && echo "            curState=$curState sufficiently recent ($JOB_INTERVAL max age)"
                    fi
                    ;;
                xFAILURE)
                    maxAge=`$EXPR $JOB_RETRY_FAILED \* 60`
		    needToQueue=`isTimeStampTooOld ${lastFailureTimeStamp:-1} $maxAge`
                    if [ $needToQueue ]; then
                        [ "$VERBOSE" ] && echo "            ENQUEUE: curState=$curState wait period $JOB_RETRY_FAILED expired"
                    else
                        [ "$VERBOSE" ] && echo "            curState=$curState too recent (wait $JOB_RETRY_FAILED before retry)"
                    fi
                    ;;
                *)
		    needToQueue=0  #0=true   
                    [ "$VERBOSE" ] && echo "            ENQUEUE: no prior state"
                    ;;
            esac
        
            if [ $needToQueue ]; then
                "${COMMAND_PATH%/*}/enqueue" "$jobPath" "-j" "$jobPath" "-s" "$modName"
                if [ $? -eq 100 ]; then
                    [ "$VERBOSE" ] && echo '            attempted enqueue but job already queued'
                fi
            fi

        done
    done
done 


