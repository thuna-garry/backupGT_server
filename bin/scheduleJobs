#! /usr/local/bin/bash

###############################################################################
# This script finds jobs that haven't successfully run within a prescribed
# time interval and queues them for execution
#
###############################################################################
# Jobs
#   Implemented as runnable files (typically shell scripts) within directories
#   subordinate to JOB_ROOT.  Jobs will be managed if they are executable and
#   located in a direcotry that also contains a JOB_CONTROL file.
#
# Job ModList
#   Associated with each job is a modList file named the same as the jobFile
#   but with $JOB_MODLIST_SUFFIX appended.
#   The modification date of this modList file is used to indicate how recently
#   the job ran. If present it will contain the module list as supplied by
#   the target host.
#   
#   When present (and recent) each module listed will be checked to see that it
#   has had a successful completion within the JOB_INTERVAL (specified in the
#   JOB_CONTROL file). If not it will be scheduled (enqueued) to run.  Failed
#   jobs will only be re-scheduled after a minimum wait of JOB_RETRY_INTERVAL.  # 
#
# Job Status
#   Associated with each job is a statud directory named the same as the jobFile
#   but with $JOB_STATUS_DIR_SUFFIX appended.
#   Within this directory there will be one status file for each module that has
#   been previously queued and run.  After each run of the job a line will be
#   appended with the job's completion status and some additional job control
#   information.
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012.10.14'


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# scheduleJobs (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO "Usage: $0 [-v]"
    $ECHO "   search the JOB_ROOT for job files that have not successfully completed"
    $ECHO "   within their prescribed JOB_INTERVAL (as specified in the JOB_CONTROL"
    $ECHO "   file to be found in the same directory as the job file) and queue them"
    $ECHO "   to run."
    $ECHO "Options:"
    $ECHO "  -v  verbose: prints detail of processing to stdout. "
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 [-v]"
}


parseOptions() {
    while getopts ":v" arg; do
        case $arg in
            v) VERBOSE="1" ;;
            :) $ECHO "Option -${OPTARG} requires an argument." 1>&2
               exit 1
               ;;
            *) $ECHO "Option -${OPTARG} not recognized as a valid option." 1>&2
               printFullUsage 1>&2
               exit 1
               ;;
        esac
    done
    COMMAND_LINE_PARMS=( "${@:$OPTIND}" )  #save rest of command line as array
}


#------
# determine if a module should be queued based on examination of status files
#------
needToQueue () {
    local jobPath="$1"
    local modName="$2"
    local needed 

    local statusDir="${jobPath}${JOB_STATUS_DIR_SUFFIX}"
    local statusPath="${statusDir}/${modName}"
    local statLine=`$SORT $statusPath 2>/dev/null | $TAIL -1`

    local curState=`       $ECHO "$statLine" | parseAssignment curState`
    local lastSuccessDate=`$ECHO "$statLine" | parseAssignment lastSuccessDate`
    local lastFailureDate=`$ECHO "$statLine" | parseAssignment lastFailureDate`
            
    case x$curState in
        xSUCCESS)
            if isDateStampTooOld $lastSuccessDate $JOB_INTERVAL; then
                needed=0  #true
                [ "$VERBOSE" ] && $ECHO "          . ENQUEUE: curState=$curState too old (job interval $JOB_INTERVAL)"
            
            else
                needed=1  #false
                [ "$VERBOSE" ] && $ECHO "          . curState=$curState sufficiently recent (job interval $JOB_INTERVAL)"
            fi
            ;;
        xFAILURE)
            if [ 0"$JOB_RETRY_INTERVAL" -eq 0 ]; then
                needed=1  #false
                [ "$VERBOSE" ] && $ECHO "          . curState=$curState but retry on failure disabled (JOB_RETRY_INTERVAL=0)"
            else
                if isDateStampTooOld $lastFailureDate $JOB_INTERVAL; then
                    needed=0  #true
                    [ "$VERBOSE" ] && $ECHO "          . ENQUEUE: curState=$curState retry interval $JOB_RETRY_INTERVAL expired"
                else
                    needed=1  #false
                    [ "$VERBOSE" ] && $ECHO "          . curState=$curState too recent (retry interval $JOB_RETRY_INTERVAL)"
                fi
            fi
            ;;
        *)
            needed=0  #true   
            [ "$VERBOSE" ] && $ECHO "          . ENQUEUE: no prior job status"
            ;;
    esac
    return $needed
}


callEnqueue () {
    local jobPath="$1"
    local modName="$2"
    shift 2

    ${BACKUPGT_ROOT}/bin/enqueue       \
        `[ "$VERBOSE" ] && $ECHO "-v"` \
        "-j" "$jobPath"                \
        "-s" "$modName"                \
        "-p" "$JOB_PRIORITY"           \
        "--" $*
    if [ $? -eq 100 ]; then
        [ "$VERBOSE" ] && $ECHO '          . attempted enqueue but job already queued'
    fi
}


###############################################################################
# main
###############################################################################
checkRunningUser
parseOptions "$@"; set -- "${COMMAND_LINE_PARMS[@]}"

# find all the job directories with a JOB_CONTROL file
for jobControlFile in `$FIND $JOB_ROOT -name $JOB_CONTROL`; do
    jobDir=${jobControlFile%/*}
    [ "$VERBOSE" ] && $ECHO "job dir: ${jobDir##*/}  ($jobDir)"

    # set default job control parameters and souce the file
    JOB_INTERVAL=1440      #set default 1 day
    JOB_RETRY_INTERVAL=60  #set default 1 hour
    JOB_PRIORITY=50        #set default
    . $jobControlFile

    # find all the jobs in the current job directory
    for jobPath in `$FIND $jobDir -perm -0100 -type f -mindepth 1 -maxdepth 1`; do
        jobFile=${jobPath##*/}
        [ "$VERBOSE" ] && $ECHO "    job: $jobFile"

        # if a custom job control file exists then source it
        [ -f "${jobPath}${JOB_CONTROL_SUFFIX}" ] && . "${jobPath}${JOB_CONTROL_SUFFIX}"

        #----------------
        # consider the job file itself
        #----------------
        if needToQueue "$jobPath" "$JOB_MODLIST_STATUS"; then
            callEnqueue "$jobPath" "" "${COMMAND_LINE_PARMS[@]}" 
            continue
        fi
	recentModList="${jobPath}${JOB_MODLIST_SUFFIX}"
      
        #----------------
        # now consider the modules
        #----------------
        $CAT $recentModList | while read modName modComment; do
            [ "$VERBOSE" ] && $ECHO '        mod: ' $modName

            # if a custom job control file exists then source it
            [ -f "${jobPath}.${modName}${JOB_CONTROL_SUFFIX}" ] && . "${jobPath}.${modName}${JOB_CONTROL_SUFFIX}" 

            if needToQueue "$jobPath" "$modName"; then
                jobParms=`$ECHO "$modComment" | parseAssignment jobParms`
                callEnqueue "$jobPath" "$modName" "$jobParms"
            fi
        done

    done
done 


