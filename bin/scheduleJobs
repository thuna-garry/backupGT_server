#! /usr/local/bin/bash 

###############################################################################
# This script finds jobs that haven't successfully run within a prescribed
# time interval and queues them for execution
#
###############################################################################
# Jobs
#   Implemented as runnable files (typically shell scripts) within directories
#   subordinate to JOB_ROOT.  Jobs will be managed if they are executable and
#   located in a direcotry that also contains a JOB_CONTROL file.
#
# Job ModList
#   Associated with each job is a modList file named the same as the jobFile
#   but with $JOB_MODLIST_SUFFIX appended.
#   The modification date of this modList file is used to indicate how recently
#   the job ran. If present it will contain the module list as supplied by
#   the target host.
#   
#   When present (and recent) each module listed will be checked to see that it
#   has had a successful completion within the JOB_INTERVAL (specified in the
#   JOB_CONTROL file). If not it will be scheduled (enqueued) to run.  Failed
#   jobs will only be re-scheduled after a minimum wait of JOB_RETRY_INTERVAL.  # 
#
# Job Status
#   Associated with each job is a statud directory named the same as the jobFile
#   but with $JOB_STATUS_DIR_SUFFIX appended.
#   Within this directory there will be one status file for each module that has
#   been previously queued and run.  After each run of the job a line will be
#   appended with the job's completion status and some additional job control
#   information.
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012-10-14'


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# scheduleJobs (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO "Usage: $0 [-v]"
    $ECHO "   search the JOB_ROOT for job files that have not successfully completed"
    $ECHO "   within their prescribed JOB_INTERVAL (as specified in the JOB_CONTROL"
    $ECHO "   file to be found in the same directory as the job file) and queue them"
    $ECHO "   to run."
    $ECHO "Options:"
    $ECHO "  -v  verbose: prints detail of processing to stdout. "
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 [-v]"
}


parseOptions() {
    while getopts ":v" arg; do
        case $arg in
            v) VERBOSE="1" ;;
            :) $ECHO "Option -${OPTARG} requires an argument." 1>&2
               exit 1
               ;;
            *) $ECHO "Option -${OPTARG} not recognized as a valid option." 1>&2
               printFullUsage 1>&2
               exit 1
               ;;
        esac
    done
    COMMAND_LINE_PARMS=( "${@:$OPTIND}" )  #save rest of command line as array
}


#------
# determine if a module should be queued based on examination of status files
#------
needToQueue () {
    local jobPath="$1"
    local modName="$2"
    local needed 

    statusDir="${jobPath}${JOB_STATUS_DIR_SUFFIX}"
    statusPath="${statusDir}/${modName}"
    statLine=`$SORT $statusPath 2>/dev/null | $TAIL -1`

    curState=`            $ECHO "$statLine" | parseAssignment curState`
    lastSuccessTimeStamp=`$ECHO "$statLine" | parseAssignment lastSuccessTimeStamp`
    lastFailureTimeStamp=`$ECHO "$statLine" | parseAssignment lastFailureTimeStamp`
            
    case x$curState in
        xSUCCESS)
            maxAge=`$EXPR $JOB_INTERVAL \* 60`
            needed=`isTimeStampTooOld ${lastSuccessTimeStamp:-1} $maxAge`
            if [ $needed ]; then
                [ "$VERBOSE" ] && $ECHO "            ENQUEUE: curState=$curState too old ($JOB_INTERVAL max age)"
            else
                [ "$VERBOSE" ] && $ECHO "            curState=$curState sufficiently recent ($JOB_INTERVAL max age)"
            fi
            ;;
        xFAILURE)
            maxAge=`$EXPR $JOB_RETRY_INTERVAL \* 60`
            needed=`isTimeStampTooOld ${lastFailureTimeStamp:-1} $maxAge`
            if [ $needed ]; then
                [ "$VERBOSE" ] && $ECHO "            ENQUEUE: curState=$curState wait period $JOB_RETRY_INTERVAL expired"
            else
                [ "$VERBOSE" ] && $ECHO "            curState=$curState too recent (wait $JOB_RETRY_INTERVAL before retry)"
            fi
            ;;
        *)
            edToQueue=0  #0=true   
            [ "$VERBOSE" ] && $ECHO "            ENQUEUE: no prior stats"
            ;;
    esac
    return $needed
}


callEnqueue () {
    local jobPath="$1"
    local modName="$2"

    "${BACKUPGT_ROOT}/bin/enqueue"     \
        `[ "$VERBOSE" ] && $ECHO "-v"` \
        "-j" "$jobPath"                \
        "-s" "$modName"                \
        "-p" "$JOB_PRIORITY"           \
        "--"
    if [ $? -eq 100 ]; then
        [ "$VERBOSE" ] && $ECHO '            attempted enqueue but job already queued'
    fi
}


###############################################################################
# main
###############################################################################
checkRunningUser
parseOptions "$@"; set -- "${COMMAND_LINE_PARMS[@]}"

# find all the job directories with a JOB_CONTROL file
for jobControlFile in `$FIND $JOB_ROOT -name $JOB_CONTROL`; do
    jobDir=${jobControlFile%/*}
    [ "$VERBOSE" ] && $ECHO "job dir: ${jobDir##*/}  ($jobDir)"

    # set default job control parameters and souce the file
    JOB_INTERVAL=1440      #set default 1 day
    JOB_RETRY_INTERVAL=60  #set default 1 hour
    JOB_PRIORITY=50        #set default
    . $jobControlFile

    # find all the jobs in the current job directory
    for jobPath in `$FIND $jobDir -perm -0100 -type f -mindepth 1 -maxdepth 1`; do
        jobFile=${jobPath##*/}
        [ "$VERBOSE" ] && $ECHO "    job: $jobFile"

        # if a custom job control file exists then source it
        [ -f "${jobPath}${JOB_CONTROL_SUFFIX}" ] && . "${jobPath}${JOB_CONTROL_SUFFIX}"

        #----------------
        # consider the job file itself
        #----------------
        if needToQueue "${jobPath}" "${JOB_MODLIST_STATUS}"; then
            callEnqueue "${jobPath}" ""
            continue
        fi
	recentModList="${jobPath}${JOB_MODLIST_SUFFIX}"
      
        #----------------
        # now consider the modules
        #----------------
        while read modName modComment <$recentModList ; do
            [ "$VERBOSE" ] && $ECHO '        mod: ' $modName
            if needToQueue "${jobPath}" "${modName}"; then
                callEnqueue "${jobPath}" "${modName}"
            fi
        done

    done
done 


