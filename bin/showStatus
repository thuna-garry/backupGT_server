#! /usr/local/bin/bash
###############################################################################
# This script displays the most recent job and backup status
#
###############################################################################


###############################################################################
# include user defined globals and the common library
###############################################################################
. ${0%/*}/../etc/server.conf
. ${0%/*}/common.lib

# redefine $SUDO to include the configured user
SUDO=""
if [ -n "$SUDO_USER" ]; then
    SUDO="$SUDO -u $SUDO_USER"
fi


###############################################################################
# globals
###############################################################################
LAST_MODIFIED_DATE='2012.10.14'

CUR_DATE=`$DATE -u +${DATE_FORMAT%%-*}`
SEPARATOR_LINE=`$PRINTF "%78s\n" ' ' | $SED -e 's/ /-/g'`


###############################################################################
# process options
###############################################################################
printFullUsage() {
    $ECHO "###############################################################################"
    $ECHO "# showStatus (part of the backupGT suite)"
    $ECHO "# Author: Garry Thuna"
    $ECHO "# Created: 11/10/2009"
    $ECHO "# Last modified: ${LAST_MODIFIED_DATE}"
    $ECHO "###############################################################################"
    $ECHO "Usage: $0 [-h <targetHost>] [-j] [-t] [-u]"
    $ECHO "   display status for backup jobs and target hosts"
    $ECHO "Options:"
    $ECHO "  -h    only print the stats for the named targetHost"
    $ECHO "  -j    include the status for jobs"
    $ECHO "  -t    include the status for target hosts"
    $ECHO "  -u    include a summary for space utilization"
    $ECHO "  -H    scripted mode do not display any headers, footers or other decoration"
    $ECHO "If neither -j, -t, or -u is specified all are assumed"
    exit 1
}


printMiniUsage() {
    $ECHO "Usage: $0 [-h <targetHost>] [-j] [-t] [-u]"
}


SHOW_ALL=1
SHOW_JOB_STATUS=
SHOW_HOST_STATUS=
SHOW_SPACE_UTIL=
SCRIPTED_MODE=
parseOptions() {
    while getopts ":h:jtuH" arg; do
        case $arg in
            h) TARGET_HOST=${OPTARG};;
            j) SHOW_JOB_STATUS=1  ;	SHOW_ALL= ;;
            t) SHOW_HOST_STATUS=1 ;	SHOW_ALL= ;;
            u) SHOW_SPACE_UTIL=1  ;	SHOW_ALL= ;;
            H) SCRIPTED_MODE=1  ;	SHOW_ALL= ;;
            :) $ECHO "Option -${OPTARG} requires an argument." 1>&2
               printFullUsage 1>&2
               exit 1
               ;;
            *) $ECHO "Option -${OPTARG} not recognized as a valid option." 1>&2
               printFullUsage 1>&2
               exit 1
               ;;
        esac
    done
    COMMAND_LINE_PARMS=( "${@:$OPTIND}" )  #save rest of command line as array
}


###############################################################################
# status reporting routines
###############################################################################
isJobSuspect () {
    local status=$1
    local statDate=$2
 
    # get the age of the status entry
    statDate=${statDate%%-*}  # correct format
    statDate=${statDate%%_*}  # old format
    statDate=${statDate//\./}
    local elapsed=$(( ${CUR_DATE//\./} - statDate ))

    # return the isSuspect string
    if [ "$status" = "FAILURE" -o "$elapsed" -gt 1  ]; then
        $ECHO "!!"
    else
        $ECHO "  "
    fi
}


jobControlStatus () {
    local statusFile
    local jobName
    local jobPath

    local jobStatusLine
    local modStatusLine
    local curState
    local curDate

    local findName
    if [ -z "$TARGET_HOST" ]; then
        findName='*.status'
    else
        findName=${TARGET_HOST}".status"
    fi

    [ "$SCRIPTED_MODE" ] || $ECHO "$SEPARATOR_LINE"
    [ "$SCRIPTED_MODE" ] || $ECHO "- Job Control Status/Results"
    [ "$SCRIPTED_MODE" ] || $ECHO "$SEPARATOR_LINE"
    $FIND $JOB_ROOT -type d -name $findName \
    | while read statusDir; do
        statusFile=${statusDir##*/}
        jobName=${statusFile%.status}
        jobPath=${statusDir%.status}

        jobStatusLine=`tail -1 ${statusDir}/${JOB_MODLIST_STATUS}`
        curState=`$ECHO $jobStatusLine | parseAssignment curState`
        curDate=` $ECHO $jobStatusLine | parseAssignment curDate`
        $PRINTF "%-40s      %s %s %s\n" "$jobName" "`isJobSuspect $curState $curDate`" "$curState" "$curDate"

        ls $statusDir | while read modStatFile; do
            [ "modStatFile" = "${JOB_MODLIST_STATUS}" ] && continue
            modStatusLine=`tail -1 ${statusDir}/${modStatFile}`
            curState=`$ECHO $jobStatusLine | parseAssignment curState`
            curDate=` $ECHO $modStatusLine | parseAssignment curDate`
            $PRINTF "    %-40s  %s %s %s\n" "$modStatFile" "`isJobSuspect $curState $curDate`" "$curState" "$curDate"
        done
    done
    [ "$SCRIPTED_MODE" ] || $ECHO
    [ "$SCRIPTED_MODE" ] || $ECHO
}


isModSuspect () {
    local statLine=$*
 
    # convert from old format
    if $ECHO "$statLine" | $GREP -q '^[2]'; then
        statLine="curDate=$statLine"
        statLine=${statLine/[files: /files=}
        statLine=${statLine/[MBytes: /MBytes=}
        statLine=${statLine/[listGen: /listGen=}
        statLine=${statLine/[totTime: /totTime=}
        statLine=${statLine/[rc: /rc=}
        if $ECHO "$statLine" | $GREP -q 'rc=0'; then
            statLine=`$ECHO $statLine | makeAssignment curState SUCCESS`
        else
            statLine=`$ECHO $statLine | makeAssignment curState FAILURE`
        fi
    fi

    # get the age of the status entry
    local statDate=`$ECHO $statLine | parseAssignment curDate`
    statDate=${statDate%%-*}  # correct format
    statDate=${statDate%%_*}  # old format
    statDate=${statDate//\./}
    local elapsed=$(( ${CUR_DATE//\./} - statDate ))

    # get the status
    local status=`$ECHO $statLine | parseAssignment curState`

    # return the isSuspect string
    local status=`$ECHO $statLine | parseAssignment curState`
    if [ "$status" = "FAILURE" -o "$elapsed" -gt 1  ]; then
        $PRINTF "!!"
    else
        $PRINTF "  "
    fi
}


targetHostStatus () {
    local findRoot
    local findDepth

    local itemFound
    local modDir
    local modName
    local hostDir
    local hostName
    local curHost
    local lastLine

    [ "$SCRIPTED_MODE" ] || $ECHO "$SEPARATOR_LINE"
    [ "$SCRIPTED_MODE" ] || $ECHO "- Host (target) Backup Status/Results"
    [ "$SCRIPTED_MODE" ] || $ECHO "$SEPARATOR_LINE"

    if [ -z "$TARGET_HOST" ]; then
        findRoot=$STORAGE_ROOT
        findDepth=3
    else
        findRoot=$STORAGE_ROOT/$TARGET_HOST
        findDepth=2
    fi
    
    curHost=
    $FIND $findRoot -maxdepth $findDepth -name 'status' -or -name '*_WIP' | sort \
    | while read f; do
        itemFound=${f##*/}
        modDir=${f%/*}
        modName=${modDir##*/}
        hostDir=${modDir%/*}
        hostName=${hostDir##*/}

        if [ x"$hostName" != x"$curHost" ]; then
            $ECHO "$hostName"
            curHost=$hostName
        fi
        if [ "$itemFound" = 'status' ]; then
            lastLine=`$TAIL -1 $f`
            $PRINTF "    %-25s %s %s %s\n" "$modName" "`isModSuspect $lastLine`" "$lastLine"
        else
            $PRINTF "    %-25s !! %s %s\n" "$modName" "FAILURE WIP found:" "$f"
        fi
    done
    [ "$SCRIPTED_MODE" ] || $ECHO
    [ "$SCRIPTED_MODE" ] || $ECHO
}


spaceUtilization () {
    [ "$SCRIPTED_MODE" ] || $ECHO "$SEPARATOR_LINE"
    [ "$SCRIPTED_MODE" ] || $ECHO "- `$HOSTNAME` Space Utilization"
    [ "$SCRIPTED_MODE" ] || $ECHO "$SEPARATOR_LINE"

    case $SYSTEM_TYPE in
        linux)
            dfResult=`df -h ${STORAGE_ROOT} | $TAIL -1`
            $ECHO "Space = `$ECHO ${dfResult} | $CUT -d ' ' -f 4` of `$ECHO ${dfResult} | $CUT -d ' ' -f 2`"
            ;;
        bsd)
            $PRINTF "Space = %s of %s (cap: %s  dedup: %s)\n" `$ZPOOL list -Ho free  $ROOT_POOL` \
                                                              `$ZPOOL list -Ho size  $ROOT_POOL` \
                                                              `$ZPOOL list -Ho cap   $ROOT_POOL` \
                                                              `$ZPOOL list -Ho dedup $ROOT_POOL`
            ;;
    esac
    [ "$SCRIPTED_MODE" ] || $ECHO
    [ "$SCRIPTED_MODE" ] || $ECHO
}


errorSummary () {
#todo
    local failureStatus=0
    local failureWip=0
    local failure23=0
    local failureVM=0
    local failurePerm=0
    for f in $files; do
        if [ -f "$f" ] && `$TAIL -1 $f | $GREP -q FAIL` ; then
            failureStatus=$(( failureStatus + 1 ))
        elif [ -d "$f" ]; then
            failureWip=$(( failureWip + 1 ))
	elif [ -f "$f" ] && `$TAIL -1 $f | $GREP -q "rc: 23"` ; then
	    failure23=$(( failure23 + 1 ))
	elif [ -f "$f" ] && `$TAIL -1 $f | $GREP -q "size: 2.0k"` ; then
	   failureVM=$(( failureVM + 1 ))
	elif [ -f "$f" ] && `$TAIL -1 $f | $GREP -q "rc: 1"` ; then
           failurePerm=$(( failurePerm + 1 ))
        fi
    done
    if [ $((failureStatus + failureWip + failureVM + failure23 + failurePerm)) -gt 0 ]; then
        $ECHO =====
        $ECHO "Stat failures found = $failureStatus"
        $ECHO "WIP    failures found = $failureWip"
	$ECHO "VM     failures found = $failureVM"
        $ECHO "rc: 23 failures found = $failure23"
	$ECHO "Access failures found = $failurePerm"
	exit 1
    fi
    [ "$SCRIPTED_MODE" ] || $ECHO
    [ "$SCRIPTED_MODE" ] || $ECHO
}


###############################################################################
# main
###############################################################################
checkRunningUser
parseOptions "$@"; set -- "${COMMAND_LINE_PARMS[@]}"

case ${0##*/} in      #see how we are called
    showStatus)
        [ "$SHOW_ALL" -o "$SHOW_JOB_STATUS"  ] && jobControlStatus $*
        [ "$SHOW_ALL" -o "$SHOW_HOST_STATUS" ] && targetHostStatus $*
        [ "$SHOW_ALL" -o "$SHOW_SPACE_UTIL"  ] && spaceUtilization $*
        ;;
esac

